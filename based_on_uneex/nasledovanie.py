class C:
    var = 10
    _internal = 777
    __internal_mangling = 888

    def __init__(self, val):
        self.var = val

    def __str__(self):
        return "<({})>".format(self.var)

    def __add__(self, other):
        return type(self)(self.var + other.var)



'''
пользоваться описанием предыдущего объекта для конструирования следующего объекта
наследование именно описания класса (потому что есть другие способы организации наследования)
(проксирование (?))
'''

class S(C):
    def __str__(self):
        s = C.__str__(self)
        #print("SUPER SUPER SUPER", super())
        return "перегружен __str__ {}:{}".format(s, type(self))

    __repr__ = __str__

class D(S):
    def newm(self):
        return self.var%2



c = C(123)
s = S(100500)
print(s)
d = D(456)
print(c, issubclass(type(c),type(d)))
print(d, issubclass(type(d),type(c)))

'''
Это два разных класса при этом один является подклассом другого
Структура наследования C -> S -> D

Классы S,D не определяют собственных конструкторов, зато определяется собственный конструктор
в классе C и вот он то и выполняется.

Вызывается тот метод который по иерархии наследования первым попался
- Если вы хотите изменить работу соответствующего метода, просто напишите его заново
- Если вы хотите воспользоваться работой соответствующего метода из родительского класса придется вызвать этот метод путем
    имя_класса.__метод__(...)



Функцию super() коснулись, но не разобрали...
(1) метаклассы - конструкторы классов
(2) у нас есть классы это конструкторы объектов
(3) Классы это такие объекты (1)

Две хитрости:
1)     def __add__(self, other):
        return type(self)(self.var + other.var)

2)

'''
print("="*60)
print(c+s, type(c+s))
print(s+c, type(s+c))
print(isinstance(c,C), isinstance(d,D), isinstance(d,C), isinstance(c,D))

'''
объект d экземпляр класса C тоже т.к. он сделан из производного класса.
Это бывает нужно если мы хотим ограничить полиморфизм только деревом классов как это сделано
в большинстве языков программирования
чтобы методы применялись только к объектам данного типа или производным

защита полей это вопрос договоренности это не предмет синтаксиса в питоне, до определенного момента :)
По договоренности поля начинающиеся с _ считаются "слегка _internal"

не надо присваивать вручную таким полям значения и не надо вызывать методы у которых есть такие имена
их придумали разработчики для того чтобы что-то работало, эти названия вообще по договоренности могут меняться
и внутренности тоже могут меняться.

поэтому питон рассматривает вопрос случайного перебития таких методов. Например когда мы весь код класса не изучили, 
а в документации матоды и поля начинающиеся с _ описывать не обязательно. А дальше начинаем его наследовать и вертеть
как душа пожелает

далее пример на манглинг имен: начинающихся с __ но не кончающихся на __

'''

print ([i for i in dir(d) if not i.startswith("__")])  # _C__internal_mangling
d._C__internal_mangling = 900
print(d._C__internal_mangling)

