'''
Мальчик подошел к платной лестнице.
Чтобы наступить на любую ступеньку, нужно заплатить указанную на ней сумму
(положительное целое число). Мальчик умеет перешагивать на следующую ступеньку,
либо перепрыгивать через ступеньку. Требуется узнать, какая наименьшая сумма
понадобится мальчику, чтобы добраться до верхней ступеньки.
На последнюю ступеньку наступать обязательно

Input:

9,5,3,5,2,4,5,3,7,8,3,7,1,9,10,1,1,10,10,7,10,3,2,6,7,2,2,10,3,8
Output:

77

Рассуждения:
    Пусть f - функция динамического программирования.
    На i-ю ступеньку мальчик мог попасть только с (i-1)-й или с (i-2)-й ступенек.
    Значит f[i] = min(f[i-1], f[i-2]) + стоимость i-й ступеньки.

    на последнюю ступеньку наступать обязательно по условию задачи

    Решение полным перебором (крайне неэффективное, ~n!)
    Решение с помощью обхода дерева (неэффективное, ~2(n/2))
    Решение на основании рекуррентного соотношения: f(n)=min(f(n-1),f(n-2)) (сложность ~n)
'''

Stairs = list(eval(input("Введите цены ступенек платной лестницы: ")))
#Stairs = [1,1,10,10,7,5]  # 16
#Stairs=[9,5,3,5,2,4,5,3,7,8,3,7,1,9,10,1,1,10,10,7,10,3,2,6,7,2,2,10,3,8]

Stairs.reverse()
N=len(Stairs)

FullPrice = [0 for i in range(N)]
FullPrice[0], FullPrice[1] = Stairs[0], Stairs[0]

for i in range(2,N):
    FullPrice[i]=Stairs[i-1]+min(FullPrice[i-1],FullPrice[i-2])

print("Result:", FullPrice[-1])