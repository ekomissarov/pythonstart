
'''
Штаб гражданской обороны Тридесятой области решил обновить план спасения на случай ядерной атаки.
Известно, что все n селений Тридесятой области находятся вдоль одной прямой дороги.
Вдоль дороги также расположены m бомбоубежищ, в которых жители селений могут укрыться на случай ядерной атаки.

Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее, необходимо для каждого селения
определить ближайшее к нему бомбоубежище.

Формат ввода

В первой строке вводится число n - количество селений (1 <= n <= 100000).
Вторая строка содержит n различных целых чисел, i-е из этих чисел задает
расстояние от начала дороги до i-го селения. В третьей строке входных данных
задается число m - количество бомбоубежищ (1 <= m <= 100000). Четвертая строка
содержит m различных целых чисел, i-е из этих чисел задает расстояние от начала
дороги до i-го бомбоубежища. Все расстояния положительны и не превышают 10⁹.
Селение и убежище могут располагаться в одной точке.

Формат вывода

Выведите n чисел - для каждого селения выведите номер ближайшего к нему бомбоубежища.
Бомбоубежища пронумерованы от 1 до m в том порядке, в котором они заданы во входных данных.

Указание

Создайте список кортежей из пар (позиция селения, его номер в исходном списке),
а также аналогичный список для бомбоубежищ. Отсортируйте эти списки.

Перебирайте селения в порядке возрастания.

Для селения ближайшими могут быть два соседних бомбоубежища, среди них надо выбрать ближайшее.
При переходе к следующему селению не обязательно искать ближайшее бомбоубежище с самого начала.
Его можно искать начиная с позиции, найденной для предыдущего города.

Для хранения ответа используйте список, где индекс будет номером селения,
а по этому индексу будет запоминаться номер бомбоубежища.

пример входных данных
10
23 43 45 42 34 76 97 45 11 7
10
1 23 43 37 84 2 34 56 87 78

'''


result = [] # (номер селения, номер ближайшего бомбаря)

n = int(input("кол-во селений:"))
listT = list((i,int(j)) for i,j in enumerate(input("расстояния:").split()))

m = int(input("кол-во бомбарей:"))
listV = list((i,int(j)) for i,j in enumerate(input("расстояния:").split()))

listT.sort(key = lambda val: val[1])  # сортируем дома в порядке возрастания
listV.sort(key = lambda val: val[1], reverse=True)  # сортируем бомбари в порядке убывания
# чтобы удалять их из конца массива по мере работы алгоритма.
# Операция удаления из конца массива имеет константную сложность


for selenie in listT:  # проход по селениям

    min_dist = abs(selenie[1] - listV[len(listV)-1][1])  # инициализируем начальное значение
    for i in range(len(listV)-2, -1, -1):  # проход по бомбарям с конца
        d = abs(selenie[1] - listV[i][1])
        if (min_dist >= d):
            min_dist = d  # выбор ближайшего бомбаря с мин расстоянием
        else:
            # result.append((selenie[0], listV[i+1][0], min_dist))  # (номер селения, номер бомбаря, расстояние между для отладки)
            result.append((selenie[0], listV[i+1][0]))
            del listV[i+2:] # удаляем с i+2 чтобы попробовать лучший бомбарь на текущем шаге для следующего поселения
            break
    else:
        result.append((selenie[0], listV[i][0]))

result.sort(key = lambda val: val[0])
for i in result:
    print(i[1], end = " ")




